# azure-pipelines.yml - Aşama 1: Temel CI Akışı

trigger:
  branches:
    include:
      - main
  paths:
    include:
      - 'user_service/*' # Sadece user-service dizinindeki değişikliklerde tetiklenir.

pool:
  name: 'Default' # Lütfen kendi Azure DevOps agent pool adınızla değiştirin.

variables:
  # --- Genel Değişkenler ---
  serviceName: 'user_service'
  harborRepo: 'harbor.cloudpro.com.tr/helpdesk/$(serviceName)'
  imageTag: '$(Build.BuildId)' # Şimdilik basitçe Build ID'yi kullanıyoruz.
  k8sNamespace: 'ado-agents' # Kaniko pod'unun çalışacağı namespace.
  
  # --- Kaniko Konfigürasyon Değişkenleri ---
  # DÜZELTME: 'git://' ön eki kaldırıldı ve private repo URL'si kullanıldı.
  kanikoContext: 'https://dev.azure.com/umutcelik0234/HelpDesk_App/_git/helpdesk-app-src'
  kanikoContextSubPath: '$(serviceName)' # Monorepo içinde hangi alt klasörde çalışılacak.
  kanikoDockerfile: 'Dockerfile' # Context sub-path'e göreli Dockerfile yolu.
  
  # --- Dosya Yolu Değişkenleri ---
  kanikoTemplateFile: 'kaniko-pod-template.yaml' # Repo kök dizinindeki şablon.
  kanikoFinalFile: '$(Build.ArtifactStagingDirectory)/kaniko-pod-final.yaml' # Geçici olarak oluşturulan manifest.

stages:
- stage: Build
  displayName: 'Build and Push Service Image'
  jobs:
  - job: BuildImage
    displayName: 'Build $(serviceName) with Kaniko'
    steps:
    - task: Bash@3
      displayName: '1. Prepare Kaniko Pod Manifest'
      inputs:
        targetType: 'inline'
        # Best Practice: Karmaşık script'ler harici dosyalarda olmalı. 
        # Bu 'sed' komutları basit olduğu için şimdilik burada kalabilir.
        # İlerleyen aşamalarda bu adımı da bir şablona taşıyacağız.
        script: |
          echo "Preparing manifest for $(serviceName)..."
          cp "$(kanikoTemplateFile)" "$(kanikoFinalFile)"
          
          # Pod manifestindeki yer tutucuları değişkenlerle dolduruyoruz.
          sed -i "s|__POD_NAME__|kaniko-build-$(imageTag)|g" "$(kanikoFinalFile)"
          sed -i "s|__CONTEXT__|$(kanikoContext)|g" "$(kanikoFinalFile)"
          sed -i "s|__CONTEXT_SUB_PATH__|$(kanikoContextSubPath)|g" "$(kanikoFinalFile)"
          sed -i "s|__DOCKERFILE__|$(kanikoDockerfile)|g" "$(kanikoFinalFile)"
          sed -i "s|__DESTINATION_TAG__|$(harborRepo):$(imageTag)|g" "$(kanikoFinalFile)"
          
          # Best Practice: GitOps için 'latest' tag'ini kullanmıyoruz. Bu satırı kaldırıyoruz.
          sed -i "/__DESTINATION_LATEST__/d" "$(kanikoFinalFile)"
          
          echo "--- Final Kaniko Pod Manifest ---"
          cat "$(kanikoFinalFile)"

    - task: Kubernetes@1
      displayName: '2. Apply Kaniko Pod to Cluster'
      inputs:
        # Best Practice: Ajanın pod'una atanmış ServiceAccount'ı kullanıyoruz. 
        # Bu, cluster'a erişim için pipeline'da ek secret'lar tutma ihtiyacını ortadan kaldırır. 
        connectionType: 'None' 
        namespace: '$(k8sNamespace)'
        command: 'apply'
        arguments: '-f $(kanikoFinalFile)'
        
    - task: Kubernetes@1
      displayName: '3. Wait for Kaniko Pod to Complete'
      inputs:
        connectionType: 'None'
        namespace: '$(k8sNamespace)'
        command: 'wait'
        arguments: 'pod/kaniko-build-$(imageTag) --for=condition=Succeeded --timeout=10m'

    - task: Kubernetes@1
      displayName: '4. Get Kaniko Pod Logs (for debugging)'
      condition: always() # Önceki adımlar başarısız olsa bile logları al.
      inputs:
        connectionType: 'None'
        namespace: '$(k8sNamespace)'
        command: 'logs'
        arguments: 'pod/kaniko-build-$(imageTag)'
        failOnStdErr: false # Hata logları olsa bile pipeline'ı bu adımda durdurma.

    - task: Kubernetes@1
      displayName: '5. Cleanup: Delete Kaniko Pod'
      condition: always() # Her durumda pod'u silerek temizlik yap.
      inputs:
        connectionType: 'None'
        namespace: '$(k8sNamespace)'
        command: 'delete'
        arguments: 'pod/kaniko-build-$(imageTag) --ignore-not-found=true'