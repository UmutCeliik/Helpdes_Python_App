# templates/build-service-job.yml
# Her adımın kendi ideal konteynerinde çalıştığı, son ve kararlı sürüm.

# Şablonun dışarıdan alacağı parametreler.
parameters:
- name: serviceName  # Build edilecek servisin adı (örn: 'user_service')
  type: string
- name: dependsOn    # Bu işin bağımlı olduğu önceki iş(ler)
  type: object
  default: []
- name: condition    # Bu işin çalışması için gereken koşul
  type: string
  default: succeeded()

jobs:
- job: Build_${{ parameters.serviceName }}
  displayName: 'Build Image for ${{ parameters.serviceName }}'
  dependsOn: ${{ parameters.dependsOn }}
  condition: ${{ parameters.condition }}
  
  # YENİ BÖLÜM: Bu iş için kullanılacak konteyner kaynaklarını (sidecar'lar) tanımlıyoruz.
  # Pipeline ajanı, adımları bu konteynerlerin içinde çalıştıracak.
  resources:
    containers:
    # Python taramaları için kullanılacak, içinde Python ve pip'in hazır olduğu konteyner.
    - container: python_scanner
      image: python:3.11-slim
    # Node.js taramaları için kullanılacak, içinde Node.js ve npm'in hazır olduğu konteyner.
    - container: node_scanner
      image: node:20-alpine
  
  variables:
    # Parametreden gelen değeri, bu işin (job) çalışma zamanı değişkenine atıyoruz.
    serviceName: ${{ parameters.serviceName }} 
  
  steps:
  # Kaynak kod, iş başladığında varsayılan olarak ana ajan ortamına checkout edilir.
  # Diğer konteynerler bu çalışma alanına erişebilir.
  - checkout: self

  # Python servisleri için SCA Tarama adımı
  - task: Bash@3
    displayName: 'Install & Scan Python Dependencies'
    # Bu adım, sadece build edilen servis 'frontend' DEĞİLSE çalışır.
    condition: and(succeeded(), ne(variables.serviceName, 'frontend'))
    # Bu adımı 'python_scanner' konteynerinin içinde çalıştır.
    target: python_scanner 
    inputs:
      targetType: 'inline'
      script: |
        set -e
        # Azure DevOps, kaynak kodu bu konteynere otomatik olarak /__w/{jobId}/s gibi bir yola mount eder.
        # Bu, $(Pipeline.Workspace)/s'e denk gelir.
        cd $(Pipeline.Workspace)/s/${{ parameters.serviceName }}
        echo "Running Python SCA in $(pwd) inside a Python container..."
        python -m pip install --upgrade pip
        pip install -r requirements.txt pip-audit
        echo "Scanning vulnerabilities with pip-audit..."
        pip-audit -r requirements.txt --fail-on HIGH
        echo "Python SCA Scan completed successfully."

  # Frontend servisi için SCA Tarama adımı
  - task: Bash@3
    displayName: 'Install & Scan Node.js Dependencies'
    # Bu adım, sadece build edilen servis 'frontend' İSE çalışır.
    condition: and(succeeded(), eq(variables.serviceName, 'frontend'))
    # Bu adımı 'node_scanner' konteynerinin içinde çalıştır.
    target: node_scanner 
    inputs:
      targetType: 'inline'
      script: |
        set -e
        cd $(Pipeline.Workspace)/s/${{ parameters.serviceName }}
        echo "Running Node.js SCA in $(pwd) inside a Node.js container..."
        npm ci
        echo "Scanning vulnerabilities with npm audit..."
        npm audit --audit-level=high || (echo "npm audit found vulnerabilities" && exit 1)
        echo "Node.js SCA Scan completed successfully."

  # --- KANIKO ADIMLARI (DEĞİŞİKLİK YOK) ---
  # Bu adımlar, bir 'target' belirtilmediği için varsayılan ajan ortamında çalışır
  # ve kendi pod'larını Kubernetes üzerinde oluştururlar.
  - task: Bash@3
    name: PrepareManifest
    displayName: 'Prepare Kaniko Pod Manifest for ${{ parameters.serviceName }}'
    env:
      AZP_TOKEN: $(System.AccessToken)
    inputs:
      targetType: 'inline'
      script: |
        echo "Preparing manifest for build $(imageTag) for service: $(serviceName)..."
        safePodSuffix=$(echo "$(serviceName)" | sed 's/_/-/g')
        finalPodName="kaniko-build-$(imageTag)-$safePodSuffix"
        echo "##vso[task.setvariable variable=safePodName]$finalPodName"
        finalManifestFile="$(kanikoFinalFile)-$(serviceName)"
        cp "$(kanikoTemplateFile)" "$finalManifestFile"
        sed -i "s|__POD_NAME__|$finalPodName|g" "$finalManifestFile"
        sed -i "s|__CONTEXT__|$(gitRepoUrl)|g" "$finalManifestFile"
        sed -i "s|__CONTEXT_SUB_PATH__|$(serviceName)|g" "$finalManifestFile"
        sed -i "s|__DESTINATION_TAG__|$(harborRepo)/$(serviceName):$(imageTag)|g" "$finalManifestFile"
        sed -i "s|__AZP_TOKEN__|$AZP_TOKEN|g" "$finalManifestFile"
        echo "--- Final Kaniko Pod Manifest for $(serviceName) ---"
        cat "$finalManifestFile" | sed "s/$AZP_TOKEN/********/g"

  - task: Kubernetes@1
    displayName: 'Apply Kaniko Pod for ${{ parameters.serviceName }}'
    inputs:
      connectionType: 'None'
      namespace: '$(k8sNamespace)'
      command: 'apply'
      arguments: '-f $(kanikoFinalFile)-${{ parameters.serviceName }}'
      
  - task: Kubernetes@1
    displayName: 'Wait for Init Container (git-checkout) to Complete'
    inputs:
      connectionType: 'None'
      namespace: '$(k8sNamespace)'
      command: 'logs'
      arguments: 'pod/$(safePodName) --follow --container=git-checkout'

  - task: Kubernetes@1
    displayName: 'Follow Logs for Main Container (kaniko)'
    inputs:
      connectionType: 'None'
      namespace: '$(k8sNamespace)'
      command: 'logs'
      arguments: 'pod/$(safePodName) --follow --container=kaniko'
      
  - task: Kubernetes@1
    displayName: 'Cleanup Pod for ${{ parameters.serviceName }}'
    condition: always()
    inputs:
      connectionType: 'None'
      namespace: '$(k8sNamespace)'
      command: 'delete'
      arguments: 'pod/$(safePodName) --ignore-not-found=true'