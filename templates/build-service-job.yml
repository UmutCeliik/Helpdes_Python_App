# templates/build-service-job.yml
# SonarQube durumuna bağlı olan 'condition' ifadeleri düzeltilmiş tam versiyon.

parameters:
- name: serviceName
  type: string
- name: sonarProjectKey
  type: string
- name: dependsOn
  type: object
  default: []
- name: condition
  type: string
  default: succeeded()

jobs:
- job: Build_${{ parameters.serviceName }}
  displayName: 'Scan & Build for ${{ parameters.serviceName }}'
  dependsOn: ${{ parameters.dependsOn }}
  condition: ${{ parameters.condition }}
  timeoutInMinutes: 45

  variables:
    serviceName: ${{ parameters.serviceName }}
    sonarProjectKey: ${{ parameters.sonarProjectKey }}
    NEXUS_USERNAME: $(NexusUsername)
    NEXUS_PASSWORD: $(NexusPassword)
    NEXUS_URL: $(NexusUrl)
    NEXUS_HOST: $(NexusUrl:https://([^/]+).*$) # Sadece host kısmını çeker

  steps:
  - checkout: self

  # # ===================================================================
  # # BÖLÜM 1: SCA TARAMA POD'U (Yorumlu bırakıldı)
  # # ===================================================================
  # - task: Bash@3
  #   name: PrepareScaManifest
  #   displayName: '1a. Prepare SCA Pod Manifest'
  #   env:
  #     AZP_TOKEN: $(System.AccessToken)
  #   inputs:
  #     targetType: 'inline'
  #     script: |
  #       echo "Preparing SCA manifest for service: $(serviceName)..."
  #       if [[ "$(serviceName)" == "frontend" ]]; then SCANNER_IMAGE="node:20-slim"; SERVICE_TYPE="frontend"; else SCANNER_IMAGE="python:3.11-slim"; SERVICE_TYPE="backend"; fi
  #       safePodSuffix=$(echo "$(serviceName)" | sed 's/_/-/g'); scaPodName="sca-$(imageTag)-$safePodSuffix"; echo "##vso[task.setvariable variable=scaPodName]$scaPodName"
  #       cp templates/sca-pod-template.yaml "$(kanikoFinalFile)-sca-$(serviceName)"
  #       sed -i "s|__POD_NAME__|$scaPodName|g" "$(kanikoFinalFile)-sca-$(serviceName)"; sed -i "s|__CONTEXT__|$(gitRepoUrl)|g" "$(kanikoFinalFile)-sca-$(serviceName)"; sed -i "s|__CONTEXT_SUB_PATH__|$(serviceName)|g" "$(kanikoFinalFile)-sca-$(serviceName)"; sed -i "s|__AZP_TOKEN__|$AZP_TOKEN|g" "$(kanikoFinalFile)-sca-$(serviceName)"; sed -i "s|__SCANNER_IMAGE__|$SCANNER_IMAGE|g" "$(kanikoFinalFile)-sca-$(serviceName)"; sed -i "s|__SERVICE_TYPE__|$SERVICE_TYPE|g" "$(kanikoFinalFile)-sca-$(serviceName)"
  # - task: Kubernetes@1
  #   displayName: '1b. Apply & Run SCA Pod'
  #   inputs: { connectionType: 'None', namespace: '$(k8sNamespace)', command: 'apply', arguments: '-f $(kanikoFinalFile)-sca-$(serviceName)' }
  # - task: Bash@3
  #   displayName: '1c. Wait for SCA Pod to Complete & Get Logs'
  #   inputs:
  #     targetType: 'inline'
  #     script: |
  #       echo "Waiting for pod $(scaPodName) to finish..."; kubectl wait --for=condition=Ready pod/$(scaPodName) --timeout=5m -n $(k8sNamespace); kubectl logs $(scaPodName) -n $(k8sNamespace) -c scanner --follow
  # - task: Kubernetes@1
  #   displayName: '1d. Cleanup SCA Pod'
  #   condition: always()
  #   inputs: { connectionType: 'None', namespace: '$(k8sNamespace)', command: 'delete', arguments: 'pod/$(scaPodName) --ignore-not-found=true' }

  # ===================================================================
  # BÖLÜM 2: SONARQUBE TARAMA POD'U
  # ===================================================================
  # DÜZELTME: PrepareSonarManifest task'ı apply task'ından önce alındı.
  - task: Bash@3
    name: PrepareSonarManifest
    displayName: '2a. Prepare SonarQube Pod Manifest'
    env:
      AZP_TOKEN_FROM_PIPELINE: $(System.AccessToken)
      SONAR_URL_FROM_PIPELINE: $(SONAR_URL)
      SONAR_TOKEN_FROM_PIPELINE: $(SONAR_TOKEN)
      SONAR_KEY_FROM_PIPELINE: $(sonarProjectKey)
    inputs:
      targetType: 'inline'
      script: |
        echo "Preparing SonarQube manifest for service: $(serviceName)..."
        echo "--- Verifying variables from Library ---"
        echo "Sonar URL is: $SONAR_URL_FROM_PIPELINE"
        echo "Sonar Project Key is: $SONAR_KEY_FROM_PIPELINE"
        
        safePodSuffix=$(echo "$(serviceName)" | sed 's/_/-/g')
        sonarPodName="sonar-$(imageTag)-$safePodSuffix"
        echo "##vso[task.setvariable variable=sonarPodName]$sonarPodName"
        cp templates/sonar-pod-template.yaml "$(kanikoFinalFile)-sonar-$(serviceName)"
        sed -i "s|__POD_NAME__|$sonarPodName|g" "$(kanikoFinalFile)-sonar-$(serviceName)"
        sed -i "s|__CONTEXT__|$(gitRepoUrl)|g" "$(kanikoFinalFile)-sonar-$(serviceName)"
        sed -i "s|__CONTEXT_SUB_PATH__|$(serviceName)|g" "$(kanikoFinalFile)-sonar-$(serviceName)"
        sed -i "s|__AZP_TOKEN__|$AZP_TOKEN_FROM_PIPELINE|g" "$(kanikoFinalFile)-sonar-$(serviceName)"
        sed -i "s|__SONAR_URL__|$SONAR_URL_FROM_PIPELINE|g" "$(kanikoFinalFile)-sonar-$(serviceName)"
        sed -i "s|__SONAR_TOKEN__|$SONAR_TOKEN_FROM_PIPELINE|g" "$(kanikoFinalFile)-sonar-$(serviceName)"
        sed -i "s|__PROJECT_KEY__|$SONAR_KEY_FROM_PIPELINE|g" "$(kanikoFinalFile)-sonar-$(serviceName)"

  - task: Kubernetes@1
    displayName: '2b. Apply & Run SonarQube Pod'
    inputs: { connectionType: 'None', namespace: '$(k8sNamespace)', command: 'apply', arguments: '-f $(kanikoFinalFile)-sonar-$(serviceName)' }
  
  - task: Bash@3
    name: SonarStatusCheck
    displayName: '2c. Wait for SonarQube Pod to Complete & Get Logs'
    inputs:
      targetType: 'inline'
      script: |
        set -x # Debug modunu aç, komutları ve değişkenleri gösterir

        echo "Waiting for pod $(sonarPodName) to finish...";
        kubectl wait --for=condition=Ready pod/$(sonarPodName) --timeout=5m -n $(k8sNamespace);
        kubectl logs $(sonarPodName) -n $(k8sNamespace) -c sonarqube-scanner --follow

        # jq'nun kurulu olup olmadığını kontrol et ve kur (eğer yoksa)
        if ! command -v jq &> /dev/null
        then
            echo "jq is not installed. Attempting to install jq..."
            # Varsayılan SonarScanner imajı genellikle Debian/Ubuntu tabanlıdır.
            apt-get update && apt-get install -y jq || \
            # Eğer imaj alpine ise:
            apk add --no-cache jq || \
            echo "Cannot install jq automatically. Please ensure jq is available in the SonarScanner image or install manually."
            # Eğer jq kurulamıyorsa, bu noktada exit edebiliriz veya manuel kontrol için uyarı verebiliriz.
            # Şimdilik devam edelim, ama bil ki bu bir sorun kaynağı olabilir.
        fi

        # Kalite geçidi durumunu çekerken --insecure ekleyelim (eğer SonarQube self-signed kullanıyorsa)
        CURL_URL="$(SONAR_URL)/api/qualitygates/project_status?projectKey=$(sonarProjectKey)"
        CURL_HEADER_AUTH="-u $(SONAR_TOKEN):"
        CURL_OUTPUT_FILE="sonarqube_quality_gate_raw_response.json"
        
        echo "Attempting to fetch SonarQube quality gate status from: $CURL_URL"
        
        # Curl komutunu çalıştır ve çıktıyı dosyaya kaydet
        # Hata durumunda (HTTP 4xx/5xx) bile dosyanın oluştuğundan emin olmak için --fail kaldırıldı,
        # ve hata çıktısını da dosyaya yazmak için 2>&1 yönlendirmesi eklendi.
        # Bu şekilde, curl bir hata sayfası veya boş yanıt döndürse bile dosyayı görebiliriz.
        curl -s --insecure $CURL_HEADER_AUTH "$CURL_URL" > $CURL_OUTPUT_FILE 2>&1
        CURL_EXIT_CODE=$? # Curl komutunun exit kodunu al

        echo "--- Curl Command Details ---"
        echo "Command: curl -s --insecure $CURL_HEADER_AUTH \"$CURL_URL\" > $CURL_OUTPUT_FILE 2>&1"
        echo "Curl Exit Code: $CURL_EXIT_CODE"
        echo "----------------------------"

        echo "--- Raw SonarQube Quality Gate API Response (from $CURL_OUTPUT_FILE) ---"
        if [ -f "$CURL_OUTPUT_FILE" ]; then # Dosya var mı? (boş olsa bile)
            if [ -s "$CURL_OUTPUT_FILE" ]; then # Dosya boş değil mi?
                cat "$CURL_OUTPUT_FILE"
                echo "" # Yeni satır ekle
            else
                echo "WARNING: $CURL_OUTPUT_FILE exists but is empty. Curl exited with code $CURL_EXIT_CODE."
                echo "This means SonarQube API returned no content for the request."
            fi
        else
            echo "ERROR: $CURL_OUTPUT_FILE was NOT created. This might indicate a file system permission issue or a critical curl error."
        fi
        echo "----------------------------------------------------------------------"
        
        # jq'yu çalıştırmak için koşul ekle
        SONAR_STATUS="API_ERROR_UNKNOWN" # Varsayılan hata durumu
        if [ -s "$CURL_OUTPUT_FILE" ]; then # Sadece dosya varsa ve boş değilse jq'yu çalıştır
            # jq ile status'u çek. Hata olursa (örn: JSON parse edilemezse) varsayılan bir değer ata.
            SONAR_STATUS_FROM_JQ=$(jq -r .projectStatus.status "$CURL_OUTPUT_FILE" 2>/dev/null)
            if [ -z "$SONAR_STATUS_FROM_JQ" ] || [ "$SONAR_STATUS_FROM_JQ" == "null" ]; then
                echo "WARNING: jq did not return a valid status (output was empty or 'null'). This might mean JSON structure is unexpected or jq failed."
                SONAR_STATUS="UNKNOWN_JSON_STRUCTURE" # jq çıktısı boşsa veya "null" ise UNKNOWN yap
            else
                SONAR_STATUS="$SONAR_STATUS_FROM_JQ"
            fi
        else
            echo "Skipping jq processing as response file is empty or missing."
        fi

        echo "Final SonarQube Quality Gate Status: $SONAR_STATUS"
        if [ "$SONAR_STATUS" != "OK" ]; then
            echo "##vso[task.logissue type=error;]SonarQube Quality Gate failed for project $(sonarProjectKey)."
            echo "##vso[task.setvariable variable=sonar_status]FAILED"
            exit 1
        else
            echo "##vso[task.setvariable variable=sonar_status]OK"
        fi

  - task: Kubernetes@1
    displayName: '2d. Cleanup SonarQube Pod'
    condition: always()
    inputs: { connectionType: 'None', namespace: '$(k8sNamespace)', command: 'delete', arguments: 'pod/$(sonarPodName) --ignore-not-found=true' }

  # # ===================================================================
  # # BÖLÜM 3: KANIKO BUILD POD'U (Yorumlu bırakıldı)
  # # ===================================================================
  # - task: Bash@3
  #   name: PrepareKanikoManifest
  #   displayName: '3a. Prepare Kaniko Manifest'
  #   env:
  #     AZP_TOKEN: $(System.AccessToken)
  #   inputs:
  #     targetType: 'inline'
  #     script: |
  #       safePodSuffix=$(echo "$(serviceName)" | sed 's/_/-/g'); kanikoPodName="kaniko-build-$(imageTag)-$safePodSuffix"; echo "##vso[task.setvariable variable=kanikoPodName]$kanikoPodName"
  #       cp "$(kanikoTemplateFile)" "$(kanikoFinalFile)-kaniko-$(serviceName)"; sed -i "s|__POD_NAME__|$kanikoPodName|g" "$(kanikoFinalFile)-kaniko-$(serviceName)"; sed -i "s|__CONTEXT__|$(gitRepoUrl)|g" "$(kanikoFinalFile)-kaniko-$(serviceName)"; sed -i "s|__CONTEXT_SUB_PATH__|$(serviceName)|g" "$(kanikoFinalFile)-kaniko-$(serviceName)"; sed -i "s|__DESTINATION_TAG__|$(harborRepo)/$(serviceName):$(imageTag)|g" "$(kanikoFinalFile)-kaniko-$(serviceName)"; sed -i "s|__AZP_TOKEN__|$AZP_TOKEN|g" "$(kanikoFinalFile)-kaniko-$(serviceName)"
  # - task: Kubernetes@1
  #   displayName: '3b. Apply & Run Kaniko Pod'
  #   inputs: { connectionType: 'None', namespace: '$(k8sNamespace)', command: 'apply', arguments: '-f $(kanikoFinalFile)-kaniko-$(serviceName)' }
  # - task: Bash@3
  #   displayName: '3c. Wait for Kaniko Pod to Complete & Get Logs'
  #   inputs:
  #     targetType: 'inline'
  #     script: |
  #       echo "Waiting for pod $(kanikoPodName) to start..."; kubectl wait --for=condition=Ready pod/$(kanikoPodName) --timeout=15m -n $(k8sNamespace); kubectl logs $(kanikoPodName) -n $(k8sNamespace) -c kaniko --follow
  # - task: Kubernetes@1
  #   displayName: '3d. Cleanup Kaniko Pod'
  #   condition: always()
  #   inputs: { connectionType: 'None', namespace: '$(k8sNamespace)', command: 'delete', arguments: 'pod/$(kanikoPodName) --ignore-not-found=true' }
  
  # BÖLÜM 4: ARTIFACT'LARI NEXUS'A YAYINLAMA
  # Python servisleri için yayınlama (User Service)
  - task: Bash@3
    displayName: '4a. Publish Python Artifacts to Nexus (User Service)'
    inputs:
      targetType: 'inline'
      script: |
        set -e
        # Hedef dizine geç
        cd $(Build.SourcesDirectory)/${{ parameters.serviceName }}

        echo "Building Python distribution for ${{ parameters.serviceName }}..."
        
        # Bağımlılıkları kur ve paketi oluştur
        pip install -r requirements.txt
        pip install wheel twine
        python setup.py sdist bdist_wheel
        
        echo "Publishing Python artifacts to Nexus hosted repository..."
        REQUESTS_VERIFY=false TWINE_USERNAME=$(NEXUS_USERNAME) TWINE_PASSWORD=$(NEXUS_PASSWORD) twine upload \
                                --repository-url $(NEXUS_URL)/repository/helpdesk-python-hosted/ \
                                dist/*
        echo "Python artifacts published successfully to Nexus."
    condition: and(succeeded(), eq('${{ parameters.serviceName }}', 'user_service'), eq(variables['sonar_status'], 'OK'))
  
  # Python servisleri için yayınlama (Ticket Service) - ARTIK POD İÇİNDE YAPILACAK
  - task: Bash@3
    name: PrepareNexusPublisherManifest
    displayName: '4a.1. Prepare Nexus Publisher Pod Manifest (Ticket Service)'
    inputs:
      targetType: 'inline'
      script: |
        set -e
        echo "Preparing Nexus Publisher manifest for service: ${{ parameters.serviceName }}..."
        
        safePodSuffix=$(echo "${{ parameters.serviceName }}" | sed 's/_/-/g')
        nexusPublisherPodName="nexus-publisher-$(imageTag)-$safePodSuffix"
        echo "##vso[task.setvariable variable=nexusPublisherPodName]$nexusPublisherPodName"
        
        cp templates/nexus-publisher-pod-template.yaml "$(kanikoFinalFile)-nexus-publisher-${{ parameters.serviceName }}"
        sed -i "s|__POD_NAME__|$nexusPublisherPodName|g" "$(kanikoFinalFile)-nexus-publisher-${{ parameters.serviceName }}"
        sed -i "s|__NEXUS_USERNAME__|$NEXUS_USERNAME|g" "$(kanikoFinalFile)-nexus-publisher-${{ parameters.serviceName }}"
        sed -i "s|__NEXUS_PASSWORD__|$NEXUS_PASSWORD|g" "$(kanikoFinalFile)-nexus-publisher-${{ parameters.serviceName }}"
        sed -i "s|__NEXUS_URL__|$NEXUS_URL|g" "$(kanikoFinalFile)-nexus-publisher-${{ parameters.serviceName }}"
        sed -i "s|__CONTEXT_SUB_PATH__|$(Build.SourcesDirectory)/${{ parameters.serviceName }}|g" "$(kanikoFinalFile)-nexus-publisher-${{ parameters.serviceName }}"
    condition: and(succeeded(), eq('${{ parameters.serviceName }}', 'ticket_service'), eq(variables['sonar_status'], 'OK'))

  - task: Kubernetes@1
    displayName: '4a.2. Apply & Run Nexus Publisher Pod (Ticket Service)'
    inputs:
      connectionType: 'None'
      namespace: '$(k8sNamespace)'
      command: 'apply'
      arguments: '-f $(kanikoFinalFile)-nexus-publisher-${{ parameters.serviceName }}'
    condition: and(succeeded(), eq('${{ parameters.serviceName }}', 'ticket_service'), eq(variables['sonar_status'], 'OK'))

  - task: Bash@3
    name: RunNexusPublisherInPod
    displayName: '4a.3. Run Python Artifacts Publish in Nexus Pod (Ticket Service)'
    inputs:
      targetType: 'inline'
      script: |
        set -x # Debug modunu aç
        echo "Waiting for pod $(nexusPublisherPodName) to start..."; 
        kubectl wait --for=condition=Ready pod/$(nexusPublisherPodName) --timeout=5m -n $(k8sNamespace);
        echo "Running commands inside pod $(nexusPublisherPodName)..."

        # Python dağıtımını ve yayınlama komutlarını pod içinde çalıştır
        kubectl exec -it $(nexusPublisherPodName) -n $(k8sNamespace) -- /bin/bash -c " \
          cd /azp/_work/$(CONTEXT_SUB_PATH) && \
          echo 'Building Python distribution for ${{ parameters.serviceName }}...' && \
          pip install -r requirements.txt && \
          python setup.py sdist bdist_wheel && \
          echo 'Publishing Python artifacts to Nexus hosted repository...' && \
          REQUESTS_VERIFY=false TWINE_USERNAME=\$NEXUS_USERNAME TWINE_PASSWORD=\$NEXUS_PASSWORD twine upload \
                                --repository-url \$NEXUS_URL/repository/helpdesk-python-hosted/ \
                                dist/* && \
          echo 'Python artifacts published successfully to Nexus.' \
        "
        # Pod'un loglarını çek
        kubectl logs $(nexusPublisherPodName) -n $(k8sNamespace) --follow
    condition: and(succeeded(), eq('${{ parameters.serviceName }}', 'ticket_service'), eq(variables['sonar_status'], 'OK'))

  - task: Kubernetes@1
    displayName: '4a.4. Cleanup Nexus Publisher Pod (Ticket Service)'
    condition: always()
    inputs:
      connectionType: 'None'
      namespace: '$(k8sNamespace)'
      command: 'delete'
      arguments: 'pod/$(nexusPublisherPodName) --ignore-not-found=true'

  # BÖLÜM 5: SBOM Üretimi ve Nexus'a Yükleme (Örnek)
  - task: Bash@3
    displayName: '5. Generate and Upload SBOM to Nexus'
    inputs:
      targetType: 'inline'
      script: |
        set -e
        # DEĞİŞİKLİK: Hedef dizine script içinde geçiliyor.
        cd $(Build.SourcesDirectory)/${{ parameters.serviceName }}

        echo "Generating SBOM for ${{ parameters.serviceName }}..."
        if [[ "${{ parameters.serviceName }}" == "user_service" || "${{ parameters.serviceName }}" == "ticket_service" ]]; then
          pip install cyclonedx-bom
          cyclonedx-bom -o sbom.json
        elif [[ "${{ parameters.serviceName }}" == "frontend" ]]; then
          npm install -g @cyclonedx/cyclonedx-npm
          cyclonedx-npm -o sbom.json
        fi

        SBOM_FILE="sbom-$(Build.BuildId)-${{ parameters.serviceName }}.json"
        mv sbom.json "$SBOM_FILE"

        echo "Uploading SBOM to Nexus Raw repository..."
        curl -v --insecure -u $(NEXUS_USERNAME):$(NEXUS_PASSWORD) \
             --upload-file "$SBOM_FILE" \
             $(NEXUS_URL)/repository/sbom-reports/$SBOM_FILE
        echo "SBOM uploaded to Nexus."
    # workingDirectory: Bu satır kaldırıldı çünkü cd komutu script içinde kullanılıyor.
    condition: succeeded()

  # - task: Bash@3
  #   displayName: 'Update Redmine Issue'
  #   condition: succeeded()
  #   inputs:
  #     targetType: 'inline'
  #     script: |
  #       ISSUE_ID=$(git log -1 --pretty=%B | grep -o '#[0-9]*' | sed 's/#//'); if [ -z "$ISSUE_ID" ]; then echo "Commit mesajında Redmine issue ID'si bulunamadı."; exit 0; fi; echo "Redmine Issue #$ISSUE_ID güncelleniyor..."; STATUS_ID_IN_PROGRESS=2; JSON_PAYLOAD=$(cat <<EOF
  #       { "issue": { "notes": "CI pipeline, $(serviceName) servisi için başarıyla tamamlandı. Build: $(Build.BuildId). Link: $(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)", "status_id": $STATUS_ID_IN_PROGRESS } }
  #       EOF
  #       ); HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -X PUT -H "Content-Type: application/json" -H "X-Redmine-API-Key: $(REDMINE_API_KEY)" -d "$JSON_PAYLOAD" "$(REDMINE_URL)/issues/$ISSUE_ID.json"); if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 300 ]; then echo "Redmine Issue #$ISSUE_ID başarıyla güncellendi. (HTTP Status: $HTTP_STATUS)"; else echo "##vso[task.logissue type=error]Redmine Issue güncellenirken hata oluştu. HTTP Status: $HTTP_STATUS"; exit 1; fi